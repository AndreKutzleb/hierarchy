package de.andre_kutzleb.hierarchy.builder.parser;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Pattern;

import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.BaseErrorListener;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.Recognizer;

import de.andre_kutzleb.hierarchy.builder.model.entry.BaseEntry;
import de.andre_kutzleb.hierarchy.builder.model.entry.BaseEntry.DATA_TYPE;
import de.andre_kutzleb.hierarchy.builder.model.entry.ConstantValueEntry;
import de.andre_kutzleb.hierarchy.builder.model.entry.CustomValueEntry;
import de.andre_kutzleb.hierarchy.builder.model.entry.DefaultValueEntry;
import de.andre_kutzleb.hierarchy.builder.model.tree.Node;
import de.andre_kutzleb.hierarchy.builder.parser.antlr4.TopicsBaseListener;
import de.andre_kutzleb.hierarchy.builder.parser.antlr4.TopicsLexer;
import de.andre_kutzleb.hierarchy.builder.parser.antlr4.TopicsParser;
import de.andre_kutzleb.hierarchy.builder.parser.antlr4.TopicsParser.OptionContext;

public class TopicsFileParser {

	private final String fileName;
	private final String fileNameWithoutEnding;
	private final String readFile;

	private final Map<String, String> options = new HashMap<>();
	private Node<BaseEntry> root = null;

	private enum ENTRY_TYPE {
		CONSTANT_VALUE, CUSTOM_WITHOUT_DEFAULT_VALUE, CUSTOM_WITH_DEFAULT_VALUE

	}

	public TopicsFileParser(InputStream streamOfFile, String fileName) throws IOException {
		this.fileName = fileName;
		String[] pathParts = fileName.split(Pattern.quote(File.separator));
		fileNameWithoutEnding = pathParts[pathParts.length - 1].trim().split(Pattern.quote("."))[0].trim();
		readFile = parseFileAndMarkIndent(streamOfFile);
	}

	public TopicsFileParser(File inputFile) throws IOException {
		fileName = inputFile.getName();
		fileNameWithoutEnding = inputFile.getName().split(Pattern.quote("."))[0].trim();
		readFile = parseFileAndMarkIndent(new FileInputStream(inputFile));

	}

	private String parseFileAndMarkIndent(InputStream fromFile) throws IOException {
		try (BufferedReader r = new BufferedReader(new InputStreamReader(fromFile))) {

			String line;
			StringBuilder str = new StringBuilder();
			while ((line = r.readLine()) != null) {
				String fourSpaceToTabs = line.replace("    ", "\t");
				for (int i = 0; i < fourSpaceToTabs.length(); i++) {
					if (fourSpaceToTabs.charAt(i) == '\t') {
						str.append("-");
					} else {
						str.append(fourSpaceToTabs.substring(i));
						str.append("\n");
						break;
					}
				}
			}
			return str.toString();
		}
	}

	public void parseTopicsFile() throws IOException {

		BaseEntry root = new BaseEntry(null, fileNameWithoutEnding, "Autogenerated Code. Changes here will be automatically overwritten.");

		Node<BaseEntry> trunk = Node.root(root);

		InputStream is = new ByteArrayInputStream(readFile.getBytes(StandardCharsets.UTF_8));

		TopicsLexer l = new TopicsLexer(new ANTLRInputStream(is));
		TopicsParser p = new TopicsParser(new CommonTokenStream(l));

		p.addParseListener(new TopicsBaseListener() {

			Node<BaseEntry> currentParent = trunk;
			Node<BaseEntry> lastAdded = trunk;

			@Override
			public void exitOption(OptionContext ctx) {
				String option = ctx.optionValue.getText();
				String withoutQuotes = option.substring(1, option.length() - 1);
				if(withoutQuotes.length() > 0) {
					options.put(ctx.optionName.getText(), withoutQuotes );					
				}
			}

			@Override
			public void exitTopicLine(TopicsParser.TopicLineContext ctx) {

				int level = ctx.indent == null ? 0 : ctx.indent.getText().length();
				// child of last visited
				if (level == lastAdded.level + 1) {
					currentParent = lastAdded;
				}
				// next entry is more to the left - we have to step back
				else if (level < lastAdded.level) {
					int backTrackSteps = lastAdded.level - level;

					for (int i = 0; i < backTrackSteps; i++) {
						lastAdded = currentParent = currentParent.parent;
					}
				}
				// illegal steps
				else if (level != lastAdded.level) {
					throw new IllegalStateException("Illegal indentation");

				}

				ENTRY_TYPE entryType = determineEntryType(ctx);
				String comment = null; // ctx.comment() == null ? null :
										// (ctx.comment().commentText == null?
										// null :
										// ctx.comment().commentText.getText());
				String name = ctx.topicName.getText();

				BaseEntry entry;
				switch (entryType) {
				case CONSTANT_VALUE: {

					// cut off 0x
					String constVal = ctx.assigned.HexIntegerLiteral().getText().substring(2);
					DATA_TYPE dataType = determineDataType(constVal);
					String constantValueName = buildConstantName(currentParent) + name;
					entry = new ConstantValueEntry(dataType, name, comment, constantValueName, constVal);
					break;
				}
				case CUSTOM_WITHOUT_DEFAULT_VALUE: {
					// cut off 0x
					String placeholder = ctx.assigned.custom().CustomHexIntegerLiteral().getText().substring(2);
					DATA_TYPE dataType = determineDataType(placeholder);
					entry = new CustomValueEntry(dataType, name, comment);
					break;
				}
				case CUSTOM_WITH_DEFAULT_VALUE: {
					// cut off 0x
					String defaultVal = ctx.assigned.custom().HexIntegerLiteral().getText().substring(2);
					String placeholder = ctx.assigned.custom().CustomHexIntegerLiteral().getText().substring(2);
					DATA_TYPE typeOfPlaceholder = determineDataType(placeholder);
					DATA_TYPE typeOfdefault = determineDataType(defaultVal);

					if (typeOfPlaceholder != typeOfdefault) {
						throw new IllegalStateException("default val does not match custom field length");
					}
					String defaultValueName = buildConstantName(currentParent) + name + "_DEFAULT";
					entry = new DefaultValueEntry(typeOfdefault, name, comment, defaultValueName, defaultVal);
					break;
				}
				default:
					throw new IllegalStateException();
				}
				lastAdded = currentParent.addChild(entry);

			}

		});

		p.addErrorListener(new BaseErrorListener() {
			@Override
			public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e) {
				throw new IllegalStateException("failed to parse at line " + line + " due to " + msg + (offendingSymbol), e);
			}
		});

		p.topics();

		this.root = trunk;
	}

	private String buildConstantName(Node<BaseEntry> node) {
		return node == null ? "" : buildConstantName(node.parent) + node.data.getName() + "__";
	}

	private DATA_TYPE determineDataType(String value) {
		switch (value.length()) {
		case 2:
			return DATA_TYPE.uint8_t;
		case 4:
			return DATA_TYPE.uint16_t;
		case 8:
			return DATA_TYPE.uint32_t;
		case 16:
			return DATA_TYPE.uint64_t;
		default:
			throw new IllegalArgumentException("for input \"" + value + "\": hex numbers needs 2, 4, 8 or 16 digits in order to be mapped to uint8, uint16, uint32, uint64");
		}
	}

	private ENTRY_TYPE determineEntryType(TopicsParser.TopicLineContext ctx) {
		if (ctx.assigned.custom() == null) {
			return ENTRY_TYPE.CONSTANT_VALUE;
		} else if (ctx.assigned.custom().HexIntegerLiteral() == null) {
			return ENTRY_TYPE.CUSTOM_WITHOUT_DEFAULT_VALUE;
		} else {
			return ENTRY_TYPE.CUSTOM_WITH_DEFAULT_VALUE;
		}
	}

	public Node<BaseEntry> getRoot() {
		return root;
	}

	public Map<String, String> getOptions() {
		return options;
	}

}
