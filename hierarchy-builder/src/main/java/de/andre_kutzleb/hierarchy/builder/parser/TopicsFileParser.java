package de.andre_kutzleb.hierarchy.builder.parser;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Pattern;

import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.BaseErrorListener;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.Recognizer;

import de.andre_kutzleb.hierarchy.builder.model.entry.BaseEntry;
import de.andre_kutzleb.hierarchy.builder.model.entry.BaseEntry.DATA_TYPE;
import de.andre_kutzleb.hierarchy.builder.model.entry.ConstantValueEntry;
import de.andre_kutzleb.hierarchy.builder.model.entry.CustomValueEntry;
import de.andre_kutzleb.hierarchy.builder.model.entry.DefaultValueEntry;
import de.andre_kutzleb.hierarchy.builder.model.tree.Node;
import de.andre_kutzleb.hierarchy.builder.parser.antlr4.TopicsBaseListener;
import de.andre_kutzleb.hierarchy.builder.parser.antlr4.TopicsLexer;
import de.andre_kutzleb.hierarchy.builder.parser.antlr4.TopicsParser;

public class TopicsFileParser {

	private final String pathToFile;
	private final Map<String,String> options = new HashMap<>();
	private Node<BaseEntry> root = null;

	private enum ENTRY_TYPE {
		CONSTANT_VALUE, CUSTOM_WITHOUT_DEFAULT_VALUE, CUSTOM_WITH_DEFAULT_VALUE

	}
	
	public TopicsFileParser(String pathToFile) {
		this.pathToFile = pathToFile;
	}

	
	public void parseTopicsFile() throws IOException {

		File fileToParse = new File(pathToFile);

		if (!fileToParse.exists()) {
			throw new FileNotFoundException();
		}

		String mainName = fileToParse.getName().split(Pattern.quote("."))[0].trim();

		BaseEntry root = new BaseEntry(null, mainName, "Autogenerated Code. Changes here will be automatically overwritten.");

		Node<BaseEntry> trunk = Node.root(root);
		
		BufferedReader r = new BufferedReader(new FileReader(fileToParse));
		String line;
		StringBuilder str = new StringBuilder();
		while((line = r.readLine()) != null) {
			String fourSpaceToTabs = line.replace("    ", "\t");
			for(int i = 0; i < fourSpaceToTabs.length(); i++) {
				if(fourSpaceToTabs.charAt(i) == '\t') {
					str.append("-");
				} else {
					str.append(fourSpaceToTabs.substring(i));
					str.append("\n");
					break;
				}
			}
		}
		
		InputStream is = new ByteArrayInputStream( str.toString().getBytes( StandardCharsets.UTF_8) );

		TopicsLexer l = new TopicsLexer(new ANTLRInputStream(is));	
		TopicsParser p = new TopicsParser(new CommonTokenStream(l));
	
		p.addParseListener(new TopicsBaseListener() {
			
			

			Node<BaseEntry> currentParent = trunk;
			Node<BaseEntry> lastAdded = trunk;
			
//			@Override
//			public void exitOption(OptionContext ctx) {
//				options.put(ctx.optionName.getText(), ctx.optionValue.getText());
//			}
			
	

			@Override
			public void exitTopicLine(TopicsParser.TopicLineContext ctx) {
				
				
				
				int level = ctx.indent == null ? 0 : ctx.indent.getText().length();
				// child of last visited
				if (level == lastAdded.level + 1) {
					currentParent = lastAdded;
				} 
				// next entry is more to the left - we have to step back
				else if (level < lastAdded.level) {
					int backTrackSteps = lastAdded.level - level;
					
					for (int i = 0; i < backTrackSteps; i++) {
						lastAdded = currentParent = currentParent.parent;
					}
				} 
				// illegal steps
				else if (level != lastAdded.level) {
					throw new IllegalStateException("Illegal indentation");

				} 

				ENTRY_TYPE entryType = determineEntryType(ctx);
				String comment = null; // ctx.comment() == null ? null : (ctx.comment().commentText == null? null : ctx.comment().commentText.getText());
				String name = ctx.topicName.getText();

				BaseEntry entry;
				switch (entryType) {
				case CONSTANT_VALUE: {

					// cut off 0x
					String constVal = ctx.assigned.HexIntegerLiteral().getText().substring(2);
					DATA_TYPE dataType = determineDataType(constVal);
					String constantValueName = buildConstantName(currentParent) + name;
					entry = new ConstantValueEntry(dataType, name, comment, constantValueName, constVal);
					break;
				}
				case CUSTOM_WITHOUT_DEFAULT_VALUE: {
					// cut off 0x
					String placeholder = ctx.assigned.custom().CustomHexIntegerLiteral().getText().substring(2);
					DATA_TYPE dataType = determineDataType(placeholder);
					entry = new CustomValueEntry(dataType, name, comment);
					break;
				}
				case CUSTOM_WITH_DEFAULT_VALUE: {
					// cut off 0x
					String defaultVal = ctx.assigned.custom().HexIntegerLiteral().getText().substring(2);
					String placeholder = ctx.assigned.custom().CustomHexIntegerLiteral().getText().substring(2);
					DATA_TYPE typeOfPlaceholder = determineDataType(placeholder);
					DATA_TYPE typeOfdefault = determineDataType(defaultVal);

					if (typeOfPlaceholder != typeOfdefault) {
						throw new IllegalStateException("default val does not match custom field length");
					}
					String defaultValueName = buildConstantName(currentParent) + name + "_DEFAULT";
					entry = new DefaultValueEntry(typeOfdefault, name, comment, defaultValueName, defaultVal);
					break;
				}
				default:
					throw new IllegalStateException();
				}
				lastAdded = currentParent.addChild(entry);

			}

		});
		


		p.addErrorListener(new BaseErrorListener() {
			@Override
			public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e) {
				throw new IllegalStateException("failed to parse at line " + line + " due to " + msg+ (offendingSymbol), e);
			}
		});
		
		p.topics();
		
		this.root = trunk;
	}

	private  String buildConstantName(Node<BaseEntry> node) {
		return node == null ? "" : buildConstantName(node.parent) + node.data.getName() + "__";
	}

	private DATA_TYPE determineDataType(String value) {
		switch (value.length()) {
		case 2:
			return DATA_TYPE.uint8_t;
		case 4:
			return DATA_TYPE.uint16_t;
		case 8:
			return DATA_TYPE.uint32_t;
		case 16:
			return DATA_TYPE.uint64_t;
		default:
			throw new IllegalArgumentException("for input \"" + value + "\": hex numbers needs 2, 4, 8 or 16 digits in order to be mapped to uint8, uint16, uint32, uint64");
		}
	}

	

	private ENTRY_TYPE determineEntryType(TopicsParser.TopicLineContext ctx) {
		if (ctx.assigned.custom() == null) {
			return ENTRY_TYPE.CONSTANT_VALUE;
		} else if (ctx.assigned.custom().HexIntegerLiteral() == null) {
			return ENTRY_TYPE.CUSTOM_WITHOUT_DEFAULT_VALUE;
		} else {
			return ENTRY_TYPE.CUSTOM_WITH_DEFAULT_VALUE;
		}
	}
	
	public Node<BaseEntry> getRoot() {
		return root;
	}
	
	public Map<String, String> getOptions() {
		return options;
	}

}
